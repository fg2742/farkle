<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Farkle — 5 Dice</title>

<style>
:root {
    --bg: #006400;
    --text: #fff;
    --accent: #ffd54f;
    --btn: #2e7d32;
    --danger: #e57373;
}

/* Base HTML/body */
html, body {
    margin: 0;
    height: 100%;
    font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
    background: var(--bg);
    color: var(--text);
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Header */
header {
    position: relative;
    top: 6px;
    margin: 0 auto 10px;
    max-width: 820px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 14px;
}

h1 {
    font-size: 20px;
    margin: 0;
}

.label-bold {
    font-size: 20px;
    font-weight: bold;
}

/* Qualification message under round label */
#qualificationInfo {
    font-size: 14px;
    text-align: right;
    margin-top: 2px;
    max-width: 820px;
    width: 100%;
    padding: 0 14px;
}

/* Main app container */
.app {
    width: 100%;
    max-width: 820px;
    min-height: 90vh;
    padding: 0 14px 14px;
    display: flex;
    flex-direction: column;
}

/* Scoreboard */
.scoreboard {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}

.player {
    background: rgba(255,255,255,0.06);
    padding: 8px 10px;
    border-radius: 8px;
    min-width: 140px;
    text-align: left;
}

.player.current {
    outline: 2px solid var(--accent);
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
}

.player .name { font-weight: 700; }
.player .score { font-size: 18px; margin-top: 6px; }

/* Dice sections */
.dice-rows {
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: center;
}

.dice-section { text-align: center; }

/* Points labels */
.points-label,
.points-label span {
    font-size: 16px;
    font-weight: 700;
    line-height: 1.2;
    display: inline-block;
    vertical-align: middle;
}

.points-label { margin-bottom: 8px; }

/* Dice container wrapper */
.dice-container-wrapper {
    width: 252px;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    height: 56px;
    align-items: center;
}

/* Dice container */
.dice-container {
    display: flex;
    gap: 8px;
}

/* Dice visuals */
.dice {
    position: relative;
    width: 44px;
    height: 44px;
    background: black;
    border-radius: 10px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 3px;
    padding: 6px;
    cursor: pointer;
    transition: transform 0.15s ease, filter 0.15s ease;
}

.pip {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    justify-self: center;
    align-self: center;
}

.dice:hover:not(.locked) {
    transform: scale(1.05);
    filter: brightness(1.1);
}

.dice.tentative {
    transform: scale(1.1);
    filter: brightness(1.2);
    box-shadow: 0 0 8px var(--accent);
}

.dice.locked {
    transform: none;
    filter: brightness(1.2);
    cursor: default;
    box-shadow: none;
}

/* Turn/Pending points */
#turnPoints,
#pendingPoints {
    font-family: inherit;
    font-weight: 700;
    font-size: 18px !important;
    line-height: 1.1;
}

/* Controls */
.controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 8px;
    min-height: 44px;
}

button {
    background: var(--btn);
    color: #fff;
    border: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    width: 120px;
    box-shadow: 0 6px 14px rgba(0,0,0,0.25);
}

button.secondary { background: #37474f; }
button.danger { background: var(--danger); }
button:disabled { opacity: 0.45; cursor: not-allowed; box-shadow: none; }

/* Message */
.message {
    width: 252px;
    margin: 12px auto 0;
    text-align: center;
    font-weight: 700;
    min-height: 24px;
}

/* Meta info */
.meta {
    font-size: 13px;
    opacity: 0.9;
    margin-top: 10px;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
}

/* Bottom help text */
#helpText {
    text-align:center;
    margin-top:20px;
    margin-bottom:12px;
    font-size:13px;
    opacity:0.9;
    line-height:1.4;
}

/* Mobile scaling */
@media (max-width: 520px) {
    .dice-container-wrapper { 
        width: 204px; 
        height: 46px;
    }
    .dice { width: 36px; height: 36px; padding: 5px; }
    .pip { width: 6px; height: 6px; }
    .player { min-width: 96px; padding: 6px; }
    button { min-width: 86px; padding: 8px 10px; }
}
</style>
</head>

<body>
  <!-- Header -->
  <header>
      <h1 class="label-bold">Farkle — 5 Dice</h1>
      <div>
          <div id="roundLabel" class="label-bold">Round 1</div>
          <div id="qualificationInfo"></div>
      </div>
  </header>

  <!-- Main app container -->
  <div class="app">
      <!-- Scoreboard -->
      <div class="scoreboard" id="scoreboard"></div>

      <!-- Dice rows -->
      <div class="dice-rows">
          <!-- Held dice section -->
          <div class="dice-section">
              <div class="points-label"><strong>Turn points:</strong> <span id="turnPoints">0</span></div>
              <div class="dice-container-wrapper">
                  <div class="dice-container" id="heldContainer"></div>
              </div>
          </div>

          <!-- Current roll section -->
          <div class="dice-section">
              <div class="points-label"><strong>Selected points:</strong> <span id="pendingPoints">0</span></div>
              <div class="dice-container-wrapper">
                  <div class="dice-container" id="rollContainer"></div>
              </div>
          </div>
      </div>

      <!-- Turn message (above buttons) -->
      <div class="message" id="message" style="margin-top:14px;"></div>

      <!-- Controls (buttons) -->
      <div class="controls">
          <button id="rollBtn">Roll</button>
          <button id="bankBtn" class="secondary">Bank</button>
          <button id="endBtn" class="danger" style="visibility:hidden;">End Turn</button>
          <button id="newBtn" class="secondary">New Game</button>
      </div>

      <!-- Meta info -->
      <div class="meta" id="meta"></div>

      <!-- Bottom help text -->
      <div id="helpText">
          Tap dice in current roll to select/unselect before committing with Roll, Bank, or End Turn.
      </div>
  </div>



<script>
// --------------------------
// CONSTANTS
// --------------------------
const MIN_QUALIFY_POINTS = 600;
const STRAIGHT_SCORE = 1500;
const MAX_DICE = 5;
const MESSAGE_TIMEOUT = 1500;

// --------------------------
// DOM REFERENCES
// --------------------------
const dom = {
    heldContainer: document.getElementById('heldContainer'),
    rollContainer: document.getElementById('rollContainer'),
    turnPointsEl: document.getElementById('turnPoints'),
    pendingPointsEl: document.getElementById('pendingPoints'),
    messageEl: document.getElementById('message'),
    scoreboardEl: document.getElementById('scoreboard'),
    roundLabel: document.getElementById('roundLabel'),
    qualificationEl: document.getElementById('qualificationInfo'),
    rollBtn: document.getElementById('rollBtn'),
    bankBtn: document.getElementById('bankBtn'),
    endBtn: document.getElementById('endBtn'),
    newBtn: document.getElementById('newBtn')
};

// --------------------------
// Dice pip positions
// --------------------------
const pipMap = {
    1: [[1,1]],
    2: [[0,0],[2,2]],
    3: [[0,0],[1,1],[2,2]],
    4: [[0,0],[0,2],[2,0],[2,2]],
    5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
    6: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,2]]
};

// --------------------------
// Game state
// --------------------------
let players = [], currentPlayer = 0, round = 1;
let rolledDice = [], tentativeSet = new Set(), heldDice = [];
let turnPoints = 0, hasRolledThisTurn = false, farkled = false;

// --------------------------
// Utility functions
// --------------------------
const countsOf = arr => { const c=[0,0,0,0,0,0]; arr.forEach(v=>c[v-1]++); return c; }
const tripleValue = f => f===1?1000:f*100;
const checkStraight = roll => roll.length!==5 ? false : [...roll].sort((a,b)=>a-b).join(',')==='1,2,3,4,5'||[...roll].sort((a,b)=>a-b).join(',')==='2,3,4,5,6';
const hasScoringDice = roll => {
    if(roll.length===0) return false;
    if(roll.some(v=>v===1||v===5)) return true;
    const c=countsOf(roll);
    if(c.some(v=>v>=3)) return true;
    if(roll.length===5 && checkStraight(roll)) return true;
    return false;
}
const rand1to6 = () => Math.floor(Math.random()*6)+1;
const setMessage = msg => dom.messageEl.textContent = msg;

// --------------------------
// Game initialization
// --------------------------
function promptPlayers(){
    let num=parseInt(prompt("Number of players (1-4):","1"));
    if(isNaN(num)||num<1||num>4) num=2;
    players=[];
    for(let i=0;i<num;i++){
        let n=prompt(`Name for player ${i+1}:`,`Player ${i+1}`);
        players.push({name:n||`Player ${i+1}`,score:0,qualified:false});
    }
    currentPlayer=0;
    round=1;
    resetTurnState();
    dom.roundLabel.textContent='Round '+round;
    dom.qualificationEl.textContent='';
}

function resetTurnState(){
    rolledDice=[];
    tentativeSet.clear();
    heldDice=[];
    turnPoints=0;
    hasRolledThisTurn=false;
    farkled=false;
    setMessage(`${players[currentPlayer].name}'s turn — press Roll.`);
    renderAll();
}

// --------------------------
// Scoring
// --------------------------
function calculateScore(dice){
    if(dice.length===0) return 0;
    const c=countsOf(dice);
    let score=0;
    if(dice.length===5 && checkStraight(dice)) return STRAIGHT_SCORE;
    for(let i=0;i<6;i++){
        if(c[i]>=3){
            let base=i===0?1000:(i+1)*100;
            if(c[i]===4) score+=base+Math.round(base*0.5);
            else if(c[i]>=5) score+=2000;
            else score+=base;
        }
    }
    c[0]=c[0]>=3?c[0]-3:c[0];
    c[4]=c[4]>=3?c[4]-3:c[4];
    score+=c[0]*100 + c[4]*50;
    return score;
}

// --------------------------
// Commit tentative dice
// --------------------------
function commitTentativeAndAward(){
    if(tentativeSet.size===0) return 0;
    const newHeld=[], remainingDice=[];
    rolledDice.forEach((die,i)=>tentativeSet.has(i)?newHeld.push(die):remainingDice.push(die));
    heldDice=heldDice.concat(newHeld);
    rolledDice=remainingDice;
    tentativeSet.clear();
    const award=calculateScore(newHeld);
    turnPoints+=award;
    if(award>0) setMessage(`Added ${award} points! Total this turn: ${turnPoints}`);
    renderAll();
    return award;
}

// --------------------------
// Render dice
// --------------------------
function renderDice(container,diceArr,highlightSet,isLocked=false){
    container.innerHTML='';
    diceArr.forEach((v,i)=>{
        const el=document.createElement('div');
        el.className='dice';
        if(isLocked) el.classList.add('locked');
        else if(highlightSet.has(i)) el.classList.add('tentative');
        if(!isLocked){
            el.dataset.idx=i;
            el.addEventListener('click',()=>toggleTentative(i));
        }
        pipMap[v].forEach(([r,c])=>{
            const pip=document.createElement('div');
            pip.className='pip';
            pip.style.gridRowStart=r+1;
            pip.style.gridColumnStart=c+1;
            el.appendChild(pip);
        });
        container.appendChild(el);
    });
}

// --------------------------
// Render all
// --------------------------
function renderAll(){
    renderDice(dom.heldContainer,heldDice,new Set(),true);
    renderDice(dom.rollContainer,rolledDice,tentativeSet);
    dom.turnPointsEl.textContent=turnPoints;
    const tentativeDice=[...tentativeSet].map(i=>rolledDice[i]);
    dom.pendingPointsEl.textContent=calculateScore(tentativeDice);
    renderScoreboard();
    updateControls();
}

// --------------------------
// Render scoreboard
// --------------------------
function renderScoreboard(){
    dom.scoreboardEl.innerHTML='';
    players.forEach((p,i)=>{
        const el=document.createElement('div');
        el.className='player'+(i===currentPlayer?' current':'');
        el.innerHTML=`<div class="name">${p.name}</div><div class="score">${p.score}</div>`;
        dom.scoreboardEl.appendChild(el);
    });
}

// --------------------------
// Update buttons
// --------------------------
function updateControls(){
    dom.rollBtn.disabled = farkled;
    dom.bankBtn.disabled = farkled;
    if(farkled || heldDice.length>0 || tentativeSet.size>0){
        dom.endBtn.style.visibility='visible';
        dom.endBtn.disabled=false;
    } else dom.endBtn.style.visibility='hidden';
}

// --------------------------
// Toggle tentative dice
// --------------------------
function toggleTentative(idx){
    if(idx<0 || idx>=rolledDice.length) return;
    tentativeSet.has(idx) ? tentativeSet.delete(idx) : tentativeSet.add(idx);
    renderAll();
}

// --------------------------
// Roll dice
// --------------------------
function doRoll(){
    if(farkled) return;
    commitTentativeAndAward();
    if(heldDice.length===MAX_DICE) heldDice=[];
    const toRoll = MAX_DICE - heldDice.length;
    rolledDice=[];
    for(let i=0;i<toRoll;i++) rolledDice.push(rand1to6());
    tentativeSet.clear();
    if(!hasScoringDice(rolledDice)){
        farkled=true;
        setMessage("You rolled a Farkle! Click End Turn.");
    } else setMessage(`${players[currentPlayer].name}'s turn — select dice and Roll/Bank.`);
    hasRolledThisTurn=true;
    renderAll();
}

// --------------------------
// Bank points
// --------------------------
function bankTurn(){
    commitTentativeAndAward();
    const player=players[currentPlayer];
    if(!player.qualified){
        if(turnPoints>=MIN_QUALIFY_POINTS){
            player.qualified=true;
            player.score+=turnPoints;
            showQualificationMessage(`${player.name} qualified with ${turnPoints} points!`);
            nextPlayerAfterEnd();
        } else {
            showQualificationMessage(`${player.name} needs at least ${MIN_QUALIFY_POINTS} points to qualify — no points added.`);
        }
        return;
    }
    player.score+=turnPoints;
    setMessage(`${player.name} banked ${turnPoints} points.`);
    nextPlayerAfterEnd();
}

// --------------------------
// End turn
// --------------------------
function endTurn(){
    if(farkled){
        setMessage(`${players[currentPlayer].name} Farkled! No points added.`);
        turnPoints=0;
        nextPlayerAfterEnd();
        return;
    }
    commitTentativeAndAward();
    const player=players[currentPlayer];
    if(!player.qualified){
        if(turnPoints>=MIN_QUALIFY_POINTS){
            player.qualified=true;
            player.score+=turnPoints;
            showQualificationMessage(`${player.name} qualified with ${turnPoints} points!`);
        } else showQualificationMessage(`${player.name} needs at least ${MIN_QUALIFY_POINTS} points to qualify — no points added.`);
        nextPlayerAfterEnd();
        return;
    }
    player.score+=turnPoints;
    setMessage(`${player.name} ends turn with ${turnPoints} points!`);
    nextPlayerAfterEnd();
}

// --------------------------
// Qualification message under round label
// --------------------------
function showQualificationMessage(msg){
    dom.qualificationEl.textContent = msg;
    setTimeout(()=>{ dom.qualificationEl.textContent=''; }, MESSAGE_TIMEOUT);
}

// --------------------------
// Next player
// --------------------------
function nextPlayerAfterEnd(){
    currentPlayer=(currentPlayer+1)%players.length;
    if(currentPlayer===0){
        round++;
        dom.roundLabel.textContent='Round '+round;
    }
    resetTurnState();
}

// --------------------------
// Initialize game on page load
// --------------------------
document.addEventListener('DOMContentLoaded', ()=>{
    dom.rollBtn.addEventListener('click', doRoll);
    dom.bankBtn.addEventListener('click', bankTurn);
    dom.endBtn.addEventListener('click', endTurn);
    dom.newBtn.addEventListener('click', promptPlayers);

    promptPlayers();
});
</script>

</body>
</html>

  </div>

<script>
// --------------------------
// CONSTANTS
// --------------------------
const MIN_QUALIFY_POINTS = 600;
const STRAIGHT_SCORE = 1500;
const MAX_DICE = 5;
const MESSAGE_TIMEOUT = 1500;

// --------------------------
// DOM REFERENCES
// --------------------------
const dom = {
    heldContainer: document.getElementById('heldContainer'),
    rollContainer: document.getElementById('rollContainer'),
    turnPointsEl: document.getElementById('turnPoints'),
    pendingPointsEl: document.getElementById('pendingPoints'),
    messageEl: document.getElementById('message'),
    scoreboardEl: document.getElementById('scoreboard'),
    roundLabel: document.getElementById('roundLabel'),
    qualificationEl: document.getElementById('qualificationInfo'),
    rollBtn: document.getElementById('rollBtn'),
    bankBtn: document.getElementById('bankBtn'),
    endBtn: document.getElementById('endBtn'),
    newBtn: document.getElementById('newBtn')
};

// --------------------------
// Dice pip positions
// --------------------------
const pipMap = {
    1: [[1,1]],
    2: [[0,0],[2,2]],
    3: [[0,0],[1,1],[2,2]],
    4: [[0,0],[0,2],[2,0],[2,2]],
    5: [[0,0],[0,2],[1,1],[2,0],[2,2]],
    6: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,2]]
};

// --------------------------
// Game state
// --------------------------
let players = [], currentPlayer = 0, round = 1;
let rolledDice = [], tentativeSet = new Set(), heldDice = [];
let turnPoints = 0, hasRolledThisTurn = false, farkled = false;

// --------------------------
// Utility functions
// --------------------------
const countsOf = arr => { const c=[0,0,0,0,0,0]; arr.forEach(v=>c[v-1]++); return c; }
const tripleValue = f => f===1?1000:f*100;
const checkStraight = roll => roll.length!==5 ? false : [...roll].sort((a,b)=>a-b).join(',')==='1,2,3,4,5'||[...roll].sort((a,b)=>a-b).join(',')==='2,3,4,5,6';
const hasScoringDice = roll => {
    if(roll.length===0) return false;
    if(roll.some(v=>v===1||v===5)) return true;
    const c=countsOf(roll);
    if(c.some(v=>v>=3)) return true;
    if(roll.length===5 && checkStraight(roll)) return true;
    return false;
}
const rand1to6 = () => Math.floor(Math.random()*6)+1;
const setMessage = msg => dom.messageEl.textContent = msg;

// --------------------------
// Game initialization
// --------------------------
function promptPlayers(){
    let num=parseInt(prompt("Number of players (1-4):","1"));
    if(isNaN(num)||num<1||num>4) num=2;
    players=[];
    for(let i=0;i<num;i++){
        let n=prompt(`Name for player ${i+1}:`,`Player ${i+1}`);
        players.push({name:n||`Player ${i+1}`,score:0,qualified:false});
    }
    currentPlayer=0;
    round=1;
    resetTurnState();
    dom.roundLabel.textContent='Round '+round;
    dom.qualificationEl.textContent='';
}

function resetTurnState(){
    rolledDice=[];
    tentativeSet.clear();
    heldDice=[];
    turnPoints=0;
    hasRolledThisTurn=false;
    farkled=false;
    setMessage(`${players[currentPlayer].name}'s turn — press Roll.`);
    renderAll();
}

// --------------------------
// Scoring
// --------------------------
function calculateScore(dice){
    if(dice.length===0) return 0;
    const c=countsOf(dice);
    let score=0;
    if(dice.length===5 && checkStraight(dice)) return STRAIGHT_SCORE;
    for(let i=0;i<6;i++){
        if(c[i]>=3){
            let base=i===0?1000:(i+1)*100;
            if(c[i]===4) score+=base+Math.round(base*0.5);
            else if(c[i]>=5) score+=2000;
            else score+=base;
        }
    }
    c[0]=c[0]>=3?c[0]-3:c[0];
    c[4]=c[4]>=3?c[4]-3:c[4];
    score+=c[0]*100 + c[4]*50;
    return score;
}

// --------------------------
// Commit tentative dice
// --------------------------
function commitTentativeAndAward(){
    if(tentativeSet.size===0) return 0;
    const newHeld=[], remainingDice=[];
    rolledDice.forEach((die,i)=>tentativeSet.has(i)?newHeld.push(die):remainingDice.push(die));
    heldDice=heldDice.concat(newHeld);
    rolledDice=remainingDice;
    tentativeSet.clear();
    const award=calculateScore(newHeld);
    turnPoints+=award;
    if(award>0) setMessage(`Added ${award} points! Total this turn: ${turnPoints}`);
    renderAll();
    return award;
}

// --------------------------
// Render dice
// --------------------------
function renderDice(container,diceArr,highlightSet,isLocked=false){
    container.innerHTML='';
    diceArr.forEach((v,i)=>{
        const el=document.createElement('div');
        el.className='dice';
        if(isLocked) el.classList.add('locked');
        else if(highlightSet.has(i)) el.classList.add('tentative');
        if(!isLocked){
            el.dataset.idx=i;
            el.addEventListener('click',()=>toggleTentative(i));
        }
        pipMap[v].forEach(([r,c])=>{
            const pip=document.createElement('div');
            pip.className='pip';
            pip.style.gridRowStart=r+1;
            pip.style.gridColumnStart=c+1;
            el.appendChild(pip);
        });
        container.appendChild(el);
    });
}

// --------------------------
// Render all
// --------------------------
function renderAll(){
    renderDice(dom.heldContainer,heldDice,new Set(),true);
    renderDice(dom.rollContainer,rolledDice,tentativeSet);
    dom.turnPointsEl.textContent=turnPoints;
    const tentativeDice=[...tentativeSet].map(i=>rolledDice[i]);
    dom.pendingPointsEl.textContent=calculateScore(tentativeDice);
    renderScoreboard();
    updateControls();
}

// --------------------------
// Render scoreboard
// --------------------------
function renderScoreboard(){
    dom.scoreboardEl.innerHTML='';
    players.forEach((p,i)=>{
        const el=document.createElement('div');
        el.className='player'+(i===currentPlayer?' current':'');
        el.innerHTML=`<div class="name">${p.name}</div><div class="score">${p.score}</div>`;
        dom.scoreboardEl.appendChild(el);
    });
}

// --------------------------
// Update buttons
// --------------------------
function updateControls(){
    dom.rollBtn.disabled = farkled;
    dom.bankBtn.disabled = farkled;
    if(farkled || heldDice.length>0 || tentativeSet.size>0){
        dom.endBtn.style.visibility='visible';
        dom.endBtn.disabled=false;
    } else dom.endBtn.style.visibility='hidden';
}

// --------------------------
// Toggle tentative dice
// --------------------------
function toggleTentative(idx){
    if(idx<0 || idx>=rolledDice.length) return;
    tentativeSet.has(idx) ? tentativeSet.delete(idx) : tentativeSet.add(idx);
    renderAll();
}

// --------------------------
// Roll dice
// --------------------------
function doRoll(){
    if(farkled) return;
    commitTentativeAndAward();
    if(heldDice.length===MAX_DICE) heldDice=[];
    const toRoll = MAX_DICE - heldDice.length;
    rolledDice=[];
    for(let i=0;i<toRoll;i++) rolledDice.push(rand1to6());
    tentativeSet.clear();
    if(!hasScoringDice(rolledDice)){
        farkled=true;
        setMessage("You rolled a Farkle! Click End Turn.");
    } else setMessage(`${players[currentPlayer].name}'s turn — select dice and Roll/Bank.`);
    hasRolledThisTurn=true;
    renderAll();
}

// --------------------------
// Bank points
// --------------------------
function bankTurn(){
    commitTentativeAndAward();
    const player=players[currentPlayer];
    if(!player.qualified){
        if(turnPoints>=MIN_QUALIFY_POINTS){
            player.qualified=true;
            player.score+=turnPoints;
            showQualificationMessage(`${player.name} qualified with ${turnPoints} points!`);
            nextPlayerAfterEnd();
        } else {
            showQualificationMessage(`${player.name} needs at least ${MIN_QUALIFY_POINTS} points to qualify — no points added.`);
        }
        return;
    }
    player.score+=turnPoints;
    setMessage(`${player.name} banked ${turnPoints} points.`);
    nextPlayerAfterEnd();
}

// --------------------------
// End turn
// --------------------------
function endTurn(){
    if(farkled){
        setMessage(`${players[currentPlayer].name} Farkled! No points added.`);
        turnPoints=0;
        nextPlayerAfterEnd();
        return;
    }
    commitTentativeAndAward();
    const player=players[currentPlayer];
    if(!player.qualified){
        if(turnPoints>=MIN_QUALIFY_POINTS){
            player.qualified=true;
            player.score+=turnPoints;
            showQualificationMessage(`${player.name} qualified with ${turnPoints} points!`);
        } else showQualificationMessage(`${player.name} needs at least ${MIN_QUALIFY_POINTS} points to qualify — no points added.`);
        nextPlayerAfterEnd();
        return;
    }
    player.score+=turnPoints;
    setMessage(`${player.name} ends turn with ${turnPoints} points!`);
    nextPlayerAfterEnd();
}

// --------------------------
// Qualification message under round label
// --------------------------
function showQualificationMessage(msg){
    dom.qualificationEl.textContent = msg;
    setTimeout(()=>{ dom.qualificationEl.textContent=''; }, MESSAGE_TIMEOUT);
}

// --------------------------
// Next player
// --------------------------
function nextPlayerAfterEnd(){
    currentPlayer=(currentPlayer+1)%players.length;
    if(currentPlayer===0){
        round++;
        dom.roundLabel.textContent='Round '+round;
    }
    resetTurnState();
}

// --------------------------
// Initialize game on page load
// --------------------------
document.addEventListener('DOMContentLoaded', ()=>{
    dom.rollBtn.addEventListener('click', doRoll);
    dom.bankBtn.addEventListener('click', bankTurn);
    dom.endBtn.addEventListener('click', endTurn);
    dom.newBtn.addEventListener('click', promptPlayers);

    promptPlayers();
});
</script>

</body>
</html>
