<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Farkle — 5 Dice</title>

<style>
/* ========================
   Root variables & colors
======================== */
:root {
    --bg: #006400;
    --text: #fff;
    --accent: #ffd54f;
    --btn: #2e7d32;
    --danger: #e57373;
}

/* ========================
   Global styles
======================== */
html, body {
    margin: 0;
    height: 100%;
    font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
    background: var(--bg);
    color: var(--text);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 16px;
}

/* ========================
   App container
======================== */
.app {
    width: 100%;
    max-width: 820px;
    min-height: 90vh;
    padding: 14px;
    display: flex;
    flex-direction: column;
}

/* ========================
   Header & scoreboard
======================== */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

h1 { 
    font-size: 20px; 
    margin: 0; 
}

.scoreboard {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}

.player {
    background: rgba(255,255,255,0.06);
    padding: 8px 10px;
    border-radius: 8px;
    min-width: 140px;
    text-align: left;
}

.player.current {
    outline: 2px solid var(--accent);
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
}

.player .name { font-weight: 700; }
.player .score { font-size: 18px; margin-top: 6px; }

.label-bold {
    font-size: 20px;
    font-weight: bold;
}

/* ========================
   Top bar & turn info
======================== */
.topbar {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.turn-info { font-size: 14px; }

/* ========================
   Dice rows & containers
======================== */
.dice-rows { display: flex; flex-direction: column; gap: 10px; align-items: center; }

.row-label { font-size: 13px; opacity: 0.9; margin-bottom: 6px; text-align: center; }

.dice-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; margin: 12px 0; min-height: 70px; }

.dice {
    position: relative;
    width: 44px;
    height: 44px;
    background: black;
    border-radius: 10px;
    display: grid;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(3,1fr);
    gap: 3px;
    padding: 6px;
    cursor: pointer;
    transition: transform 0.15s ease, filter 0.15s ease;
}

.pip {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    justify-self: center;
    align-self: center;
}

.dice:hover:not(.locked) {
    transform: scale(1.05);
    filter: brightness(1.1);
}

.dice.tentative {
    transform: scale(1.1);
    filter: brightness(1.2);
    box-shadow: 0 0 8px var(--accent);
}

.dice.locked {
    transform: none;
    filter: brightness(1.2);
    cursor: default;
    box-shadow: none;
}

/* ========================
   Controls
======================== */
.controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 8px;
    min-height: 44px;
}

button {
    background: var(--btn);
    color: #fff;
    border: none;
    padding: 10px 14px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    width: 120px;
    box-shadow: 0 6px 14px rgba(0,0,0,0.25);
}

button.secondary { background: #37474f; }
button.danger { background: var(--danger); }
button:disabled { opacity: 0.45; cursor: not-allowed; box-shadow: none; }

/* ========================
   Messages & debug
======================== */
.message { margin-top: 12px; text-align: center; font-weight: 700; min-height: 24px; }

.meta { font-size: 13px; opacity: 0.9; margin-top: 10px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

#debug {
    background: rgba(255,255,255,0.1);
    padding: 6px;
    border-radius: 6px;
    font-size: 13px;
    margin-top: 6px;
}

/* ========================
   Mobile responsiveness
======================== */
@media (max-width: 520px) {
    .dice { width: 36px; height: 36px; padding: 5px; }
    .pip { width: 6px; height: 6px; }
    .player { min-width: 96px; padding: 6px; }
    button { min-width: 86px; padding: 8px 10px; }
}
</style>
</head>
<body>

<div class="app">
    <!-- Header -->
    <header>
        <h1 class="label-bold">Farkle — 5 Dice</h1>
        <div id="roundLabel" class="label-bold">Round 1</div>
    </header>

    <!-- Scoreboard -->
    <div class="scoreboard" id="scoreboard"></div>

    <!-- Top bar (optional turn info) -->
    <div class="topbar">
        <!-- <div class="turn-info" id="turnInfo"></div> -->
    </div>

    <!-- Dice rows -->
    <div class="dice-rows">
        <div>
            <div><strong>Turn points:</strong> <span id="turnPoints">0</span></div>
            <div class="row-label"><strong>Held</strong></div>
            <div class="dice-container" id="heldContainer"></div>
        </div>
        <div>
            <div><strong>Selected points:</strong> <span id="pendingPoints">0</span></div>
            <div class="row-label"><strong>Current Roll</strong></div>
            <div class="dice-container" id="rollContainer"></div>
        </div>
    </div>

    <div style="text-align:center; margin-top:4px;">
        <small>Tap dice in current roll to select/unselect before committing with Roll, Bank, or End Turn.</small>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button id="rollBtn">Roll</button>
        <button id="bankBtn" class="secondary">Bank</button>
        <button id="endBtn" class="danger" style="visibility:hidden;">End Turn</button>
        <button id="newBtn" class="secondary">New Game</button>
    </div>

    <!-- Messages and debug -->
    <div class="message" id="message"></div>
    <div class="meta" id="meta"></div>
    <div id="debug">Debug: <span id="debugText">—</span></div>
</div>

<script>
/* ========================
   Game state variables
======================== */
let players = [], 
    currentPlayer = 0, 
    round = 1;

let rolledDice = [], 
    tentativeSet = new Set(), // indices of dice tentatively selected this roll
    heldDice = [];           // dice committed to the turn

let turnPoints = 0,          // points accumulated this turn
    hasRolledThisTurn = false, 
    farkled = false;         // true if last roll had no scoring dice

/* ========================
   DOM elements
======================== */
const heldContainer = document.getElementById('heldContainer');  // container for committed dice
const rollContainer = document.getElementById('rollContainer');  // container for current roll
// const turnInfoEl = document.getElementById('turnInfo'); 
const turnPointsEl = document.getElementById('turnPoints');      // display turn points
const messageEl = document.getElementById('message');            // main message area
const scoreboardEl = document.getElementById('scoreboard');      // scoreboard container
const roundLabel = document.getElementById('roundLabel');        // current round label
const debugText = document.getElementById('debugText');          // debug info display

/* ========================
   Utility functions
======================== */
function countsOf(arr) { 
    // Count occurrences of 1-6 in dice array
    const c = [0,0,0,0,0,0]; 
    arr.forEach(v => c[v-1]++); 
    return c; 
}

function tripleValue(f) { 
    // Return value of a triple (three-of-a-kind)
    return f===1 ? 1000 : f*100; 
}

function checkStraight(roll) { 
    // Check if roll is a straight 1-5 or 2-6
    if(roll.length !== 5) return false; 
    const s = [...roll].sort((a,b) => a-b).join(',');
    return s==='1,2,3,4,5' || s==='2,3,4,5,6'; 
}

function hasScoringDice(roll) { 
    // Return true if roll has any scoring dice (1s, 5s, triples, or straight)
    if(roll.length===0) return false; 
    if(roll.some(v => v===1 || v===5)) return true; 
    const c = countsOf(roll); 
    if(c.some(v => v>=3)) return true; 
    if(roll.length===5 && checkStraight(roll)) return true; 
    return false; 
}

function rand1to6(){ return Math.floor(Math.random()*6)+1; }

function setMessage(msg){ messageEl.textContent = msg; }

/* ========================
   Player setup
======================== */
function promptPlayers(){
    // Ask user for number of players and their names
    let num = parseInt(prompt("Number of players (1-4):","1"));
    if(isNaN(num) || num<1 || num>4) num = 2;
    players = [];
    for(let i=0;i<num;i++){
        let n = prompt(`Name for player ${i+1}:`, `Player ${i+1}`);
        players.push({name: n || `Player ${i+1}`, score:0, qualified:false});
    }
    currentPlayer = 0; 
    round = 1; 
    resetTurnState(); 
    roundLabel.textContent = 'Round ' + round;
}

/* ========================
   Turn management
======================== */
function resetTurnState(){
    // Reset all dice and turn state for new player turn
    rolledDice = []; 
    tentativeSet.clear(); 
    heldDice = [];
    turnPoints = 0; 
    hasRolledThisTurn = false; 
    farkled = false;
    setMessage(`${players[currentPlayer].name}'s turn — press Roll.`);
    renderAll();
}

/* ========================
   Scoring logic
======================== */
function calculateScore(dice){
    // Calculate score for given dice array
    if(dice.length===0) return 0;
    const c = countsOf(dice);
    let score = 0;

    // Check for straight
    if(dice.length===5 && checkStraight(dice)) return 1500;

    // Score triples (or more)
    for(let i=0;i<6;i++){
        if(c[i]>=3){
            let base = (i===0) ? 1000 : (i+1)*100;
            if(c[i]===4) score += base + Math.round(base*0.5); // 4-of-a-kind bonus
            else if(c[i]>=5) score += 2000;                     // 5-of-a-kind flat bonus
            else score += base;                                 // regular triple
        }
    }

    // Add remaining 1s and 5s not part of triples
    c[0] = c[0]>=3 ? c[0]-3 : c[0];
    c[4] = c[4]>=3 ? c[4]-3 : c[4];
    score += c[0]*100 + c[4]*50;

    return score;
}

/* ========================
   Dice & rendering
======================== */
function commitTentativeAndAward(){
    // Commit selected (tentative) dice to heldDice, award their points
    if(tentativeSet.size===0) return 0;

    const newHeld = [], remainingDice = [];
    rolledDice.forEach((die,i) => { 
        tentativeSet.has(i) ? newHeld.push(die) : remainingDice.push(die); 
    });

    heldDice = heldDice.concat(newHeld); 
    rolledDice = remainingDice; 
    tentativeSet.clear();

    const award = calculateScore(newHeld); 
    turnPoints += award;
    if(award>0) setMessage(`Added ${award} points! Total this turn: ${turnPoints}`);
    renderAll();
    return award;
}

function renderDice(container, diceArr, highlightSet, isLocked=false){
    // Render dice in container; highlight tentative or lock if committed
    container.innerHTML='';
    diceArr.forEach((v,i)=>{
        const el = document.createElement('div'); 
        el.className='dice';
        if(isLocked) el.classList.add('locked'); 
        else if(highlightSet.has(i)) el.classList.add('tentative');
        if(!isLocked){ el.dataset.idx=i; el.onclick=()=>toggleTentative(i); } else el.onclick=null;

        // Map die value to pip positions
        const pipMap = {
            1:[[1,1]], 2:[[0,0],[2,2]], 3:[[0,0],[1,1],[2,2]],
            4:[[0,0],[0,2],[2,0],[2,2]], 5:[[0,0],[0,2],[1,1],[2,0],[2,2]],
            6:[[0,0],[0,2],[1,0],[1,2],[2,0],[2,2]]
        };

        pipMap[v].forEach(([r,c])=>{
            const pip = document.createElement('div'); 
            pip.className='pip';
            pip.style.gridRowStart = r+1; 
            pip.style.gridColumnStart = c+1;
            el.appendChild(pip);
        });

        container.appendChild(el);
    });
}

function renderAll() {
    // Render both held and rolled dice, update points, scoreboard, controls, debug
    renderDice(heldContainer, heldDice, new Set(), true);
    renderDice(rollContainer, rolledDice, tentativeSet);

    turnPointsEl.textContent = turnPoints;
    const tentativeDice = [...tentativeSet].map(i => rolledDice[i]);
    const tentativeScore = calculateScore(tentativeDice);
    document.getElementById('pendingPoints').textContent = tentativeScore;

    renderScoreboard();
    updateControls();
    updateDebug();
}

/* ========================
   Debug info
======================== */
function updateDebug() {
    // Display rolled dice, counts, and potential points for debugging
    const counts = countsOf(rolledDice);
    const tentativeDice = [...tentativeSet].map(i => rolledDice[i]);
    const scoreIfHeld = calculateScore(tentativeDice);
    const totalIfHeldPlusPending = turnPoints + scoreIfHeld;

    debugText.textContent =
        `Rolled: [${rolledDice.join(', ')}], Counts: [${counts.join(', ')}], ` +
        `Score if held: ${scoreIfHeld}, Total if held + pending: ${totalIfHeldPlusPending}`;
}

/* ========================
   Scoreboard
======================== */
function renderScoreboard(){
    // Update scoreboard highlighting current player
    scoreboardEl.innerHTML='';
    players.forEach((p,i)=>{
        const el = document.createElement('div'); 
        el.className = 'player' + (i===currentPlayer ? ' current' : '');
        el.innerHTML = `<div class="name">${p.name}</div><div class="score">${p.score}</div>`;
        scoreboardEl.appendChild(el);
    });
}

/* ========================
   Controls & buttons
======================== */
function updateControls(){
    // Enable/disable buttons based on farkle status and held dice
    const rollBtn = document.getElementById('rollBtn');
    const bankBtn = document.getElementById('bankBtn');
    const endBtn = document.getElementById('endBtn');

    rollBtn.disabled = farkled;
    bankBtn.disabled = farkled;

    if(farkled || heldDice.length>0 || tentativeSet.size>0){ 
        endBtn.style.visibility = 'visible'; 
        endBtn.disabled = false; 
    } else endBtn.style.visibility = 'hidden';
}

/* ========================
   Gameplay actions
======================== */
function doRoll(){
    // Roll dice, check for Farkle, reset tentative selection
    if(farkled) return;

    commitTentativeAndAward();
    if(heldDice.length===5) heldDice=[];

    const toRoll = 5 - heldDice.length; 
    rolledDice = [];
    for(let i=0;i<toRoll;i++) rolledDice.push(rand1to6());

    tentativeSet.clear();

    if(!hasScoringDice(rolledDice)){
        farkled = true; 
        setMessage("You rolled a Farkle! Click End Turn.");
    } else {
        setMessage(`${players[currentPlayer].name}'s turn — select dice and Roll/Bank.`);
    }

    hasRolledThisTurn = true; 
    renderAll();
}

function toggleTentative(idx){
    // Toggle tentative selection for a die
    if(idx<0 || idx>=rolledDice.length) return;
    tentativeSet.has(idx) ? tentativeSet.delete(idx) : tentativeSet.add(idx);
    renderAll();
}

function bankTurn(){
    // Commit dice and add points to player score, enforce qualification rule
    commitTentativeAndAward();
    const player = players[currentPlayer];

    if(!player.qualified){
        if(turnPoints>=600){
            player.qualified = true; 
            player.score += turnPoints; 
            setMessage(`${player.name} qualified with ${turnPoints} points!`);
            nextPlayerAfterEnd();
        } else {
            setMessage(`${player.name} needs at least 600 points to qualify.`);
        }
        return;
    }

    player.score += turnPoints; 
    setMessage(`${player.name} banked ${turnPoints} points.`);
    nextPlayerAfterEnd();
}

function endTurn(){
    // End turn handling; Farkle or normal points, enforce qualification
    if(farkled){
        setMessage(`${players[currentPlayer].name} Farkled! No points added.`);
        turnPoints = 0; 
        nextPlayerAfterEnd(); 
        return;
    }

    commitTentativeAndAward();
    const player = players[currentPlayer];

    if(!player.qualified){
        if(turnPoints>=600){
            player.qualified = true; 
            player.score += turnPoints; 
            setMessage(`${player.name} qualified with ${turnPoints} points!`);
        } else {
            setMessage(`${player.name} needs at least 600 points to qualify — no points added.`);
        }
        nextPlayerAfterEnd(); 
        return;
    }

    player.score += turnPoints; 
    setMessage(`${player.name} ends turn with ${turnPoints} points!`);
    nextPlayerAfterEnd();
}

function nextPlayerAfterEnd(){
    // Advance to next player and increment round if needed
    currentPlayer = (currentPlayer + 1) % players.length;
    if(currentPlayer===0){
        round++; 
        roundLabel.textContent = 'Round ' + round;
    }
    resetTurnState();
}

/* ========================
   Initialize game
======================== */
window.onload = function(){
    document.getElementById('rollBtn').onclick = doRoll;
    document.getElementById('bankBtn').onclick = bankTurn;
    document.getElementById('endBtn').onclick = endTurn;
    document.getElementById('newBtn').onclick = promptPlayers;

    promptPlayers();
}


</script>
</body>
</html>
